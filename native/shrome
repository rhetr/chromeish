#!/usr/bin/env python
# can't use python3 due to
# http://bugs.python.org/issue26037

import json
import struct
import sys
import os
import threading
from Queue import Queue
# from queue import Queue # python3

import gi
gi.require_version('Gtk','3.0')
from gi.repository import Gtk
from gi.repository import GObject

import socket

def send_message(message):
  # sys.stdout.buffer.write(struct.pack('I', len(message))) # python3
  sys.stdout.write(struct.pack('I', len(message)))
  sys.stdout.write(message)
  sys.stdout.flush()

def native_func(queue):
  ''' read messages from chrome via Native Messaging '''
  while True:
    # queue.put(input())
    # text_length_bytes = sys.stdin.buffer.read(4) # python3
    text_length_bytes = sys.stdin.read(4)
    if len(text_length_bytes) == 0:
      if queue: queue.put(None)
      sys.exit(0)
    text_length = struct.unpack('i', text_length_bytes)[0]
    # text = sys.stdin.buffer.read(text_length).decode('utf-8') # python3
    text = sys.stdin.read(text_length).decode('utf-8')
    queue.put(text)

class cview(Gtk.TextView):
  def __init__(self):
    super(Gtk.TextView, self).__init__()
    self.set_editable(False)
    self.set_cursor_visible(False)

  def append(self, text):
    buf = self.get_buffer()
    buf.insert_at_cursor(text + "\n")
    # buf.set_text('\n'.join(buf.get_text(), text))

class MainWindow(Gtk.Window):
  def __init__(self, native_queue, server_queue, client_queue):
    super(Gtk.Window, self).__init__()
    self.native_queue = native_queue
    self.server_queue = server_queue
    self.client_queue = client_queue

    self.connect('destroy', Gtk.main_quit)

    self.set_size_request(500, 200) 
    self.set_keep_above(True)
    self.stick()
    self.set_position(1)

    # from chrome
    self.from_chrome_label = Gtk.Label("from chrome")
    self.from_chrome_text = cview()
    # self.from_chrome_text.connect()

    # to chrome
    self.to_chrome_label = Gtk.Label("to chrome")
    self.to_chrome_text = cview()

    # received from client
    self.from_client_label = Gtk.Label("from client")
    self.from_client_text = cview()

    # manual input
    self.entry = Gtk.Entry()
    self.button = Gtk.Button.new_with_label("send")

    # log
    self.log_label = Gtk.Label("log")
    self.log_text = cview()

    self.button.connect("clicked", lambda _: self.send({"text":self.entry.get_text()}))

    self.pollServerMessages()
    GObject.timeout_add(100, self.pollServerMessages)

    self.pollChromeMessages()
    GObject.timeout_add(100, self.pollChromeMessages)

    box = Gtk.VBox()
    box.pack_start(self.from_chrome_label, True, True, 0)
    box.pack_start(self.from_chrome_text, True, True, 0)
    box.pack_start(self.to_chrome_label, True, True, 0)
    box.pack_start(self.to_chrome_text, True, True, 0)
    box.pack_start(self.from_client_label, True, True, 0)
    box.pack_start(self.from_client_text, True, True, 0)
    box.pack_start(self.log_label, True, True, 0)
    box.pack_start(self.log_text, True, True, 0)
    box.pack_start(self.entry, True, True, 0)
    box.pack_start(self.button, True, True, 0)

    self.add(box)

  def pollServerMessages(self):
    while not self.server_queue.empty():
      message = self.server_queue.get_nowait()
      if message == None: return True
      self.log("client: Received {}".format(message))
      self.from_client_text.append(json.dumps(message))
      self.send(message)
      # self.log("ugh {}".format(message))
      # self.sendResult(message)
    return True

  def pollChromeMessages(self):
    #self.log("polling")
    while not self.native_queue.empty():
      message = self.native_queue.get_nowait()
      # message = json.loads(message)
      if message == None: return True
      self.log("chrome: Received {}".format(message))
      self.from_chrome_text.append(message)
      # self.log("ugh {}".format(message))
      self.sendResult(json.loads(message))
    return True

  def sendResult(self, result):
    self.log("client: Sending {}".format(result))
    self.client_queue.put(result)

  def send(self, message):
    # message = '{{"text": "{}"}}'.format(text)
    message = json.dumps(message)
    self.log("chrome: Sending {}".format(message))
    self.to_chrome_text.append(message)
    try:
      send_message(message)
    except IOError:
      self.sendResult({'err': 1, 'addr': message['addr'] })
      # errordialog = Gtk.MessageDialog(
      #     self, 
      #     0,
      #     Gtk.MessageType.INFO,
      #     Gtk.ButtonsType.OK,
      #     "chrome not connected"
      #     )
      # errordialog.run()
      # errordialog.destroy()

  def log(self, message):
    self.log_text.append(message)
    # print(message)

def getbuf(sock):
  try: 
    msg = sock.recv(4096).decode()
    return msg
  # except BlockingIOError: # python3
  except socket.error:
    return None

def serve_func(server_queue, client_queue):
  ''' terrible design '''
  server = socket.socket(socket.AF_UNIX)
  if os.path.exists('/tmp/shrome'):
    os.remove("/tmp/shrome")
  server.bind("/tmp/shrome")
  # server.settimeout(0)
  server.listen(5)
  connections = []
  tosend = []
  while True:
    # send and receive data
    for sock, addr in connections:

      # receive
      msg = ''
      sys.stderr.write("getin res\n")
      msg = getbuf(sock)
      if msg == b'':
        sys.stderr.write("sock closed\n")
        connections.remove((sock, addr))
        break
      else:
        sys.stderr.write("msg: {}\n".format(msg))
        server_queue.put({"text": msg, "addr": addr})

      # check queue
      sys.stderr.write("waiting\n")
      data = client_queue.get()
      sys.stderr.write("done waiting\n")
      if data == None: break
      tosend.append(data)

      # send data
      for data in tosend:
        if 'text' in data:
          msg = data['text']
        elif 'err' in data:
          msg = data['err']
        send_addr = data['addr']
        sys.stderr.write("addr: {}\n".format(addr))
        sys.stderr.write("send_addr: {}\n".format(send_addr))

        if send_addr == addr:
          sys.stderr.write("data: {}\n".format(data))
          try: sock.sendall(msg)
          except: pass
          tosend.remove(data)

      msg = getbuf(sock)
      if msg == b'':
        sys.stderr.write("sock closed\n")
        connections.remove((sock, addr))
        break

    # check for new connections
    try:
      sock, addr = server.accept()
      # sock.settimeout(0)
      sys.stderr.write("new client {}\n".format(addr))
      connections.append((sock, addr))
    # except BlockingIOError # python3
    except socket.error:
      pass

    
  server.close()
  os.remove("/tmp/shrome")


def main():
  native_queue = Queue()
  server_queue = Queue()
  client_queue = Queue()

  native_thread = threading.Thread(target=native_func, args=(native_queue,))
  native_thread.daemon = True
  native_thread.start()

  server_thread = threading.Thread(target=serve_func, args=(server_queue, client_queue))
  server_thread.daemon = True
  server_thread.start()

  main_window = MainWindow(native_queue, server_queue, client_queue)
  # main_window.show_all()
  Gtk.main()
  sys.exit(0)

if __name__ == '__main__':
  main()
