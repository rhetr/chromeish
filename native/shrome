#!/usr/bin/env python
# can't use python3 due to
# http://bugs.python.org/issue26037

import json
import struct
import sys
import os
import threading
from Queue import Queue
# from queue import Queue # python3

from gi.repository import GObject

import socket

def stderr(text):
    out = '[{}] {}\n'.format(threading.currentThread().getName(), text)
    sys.stderr.write(out)

def send_message(message):
  # sys.stdout.buffer.write(struct.pack('I', len(message))) # python3
  sys.stdout.write(struct.pack('I', len(message)))
  sys.stdout.write(message)
  sys.stdout.flush()

def native_func(queue):
  ''' read messages from chrome via Native Messaging '''
  stderr("init")
  while True:
    # queue.put(input())
    # text_length_bytes = sys.stdin.buffer.read(4) # python3

    stderr("reading stdin")
    text_length_bytes = sys.stdin.read(4)
    stderr("stdin read")
    if len(text_length_bytes) == 0:
      if queue: queue.put(None)
      sys.exit(0)
    stderr("2")
    text_length = struct.unpack('i', text_length_bytes)[0]
    stderr("3")
    # text = sys.stdin.buffer.read(text_length).decode('utf-8') # python3
    text = sys.stdin.read(text_length).decode('utf-8')
    stderr("4")
    queue.put(text)
    stderr("5")

class Main(GObject.GObject):
  def __init__(self, native_queue, server_queue, client_queue):
    super(GObject.GObject, self).__init__()
    self.run = GObject.MainLoop().run
    self.native_queue = native_queue
    self.server_queue = server_queue
    self.client_queue = client_queue

    self.pollServerMessages()
    GObject.timeout_add(100, self.pollServerMessages)

    self.pollChromeMessages()
    GObject.timeout_add(100, self.pollChromeMessages)

  def pollServerMessages(self):
    while not self.server_queue.empty():
      stderr("server queue triggered")
      message = self.server_queue.get_nowait()
      if message == None: return True
      self.log("client: Received {}".format(message))
      self.send(message)
      # self.sendResult(message) # echo
    return True

  def pollChromeMessages(self):
    while not self.native_queue.empty():
      stderr("native queue triggered")
      message = self.native_queue.get_nowait()
      if message == None: return True
      message = message.encode("utf-8")
      self.log("chrome: Received {}".format(message))
      self.sendResult(json.loads(message))
    return True

  def sendResult(self, result):
    self.log("client: Sending {}".format(result))
    self.client_queue.put(result)

  def send(self, message):
    message = json.dumps(message)
    self.log("chrome: Sending {}".format(message))
    try:
      send_message(message)
    except IOError:
      stderr("oops")
      self.sendResult({'err': 1, 'addr': message['addr'] })

  def log(self, message):
    stderr(message)

def getbuf(sock):
  try: 
    msg = sock.recv(4096).decode()
    return msg
  # except BlockingIOError: # python3
  except socket.error:
    stder("oops")
    return None

def serve_func(server_queue, client_queue):
  ''' terrible design '''
  stderr("init")
  server = socket.socket(socket.AF_UNIX)
  if os.path.exists('/tmp/shrome'):
    os.remove("/tmp/shrome")
  server.bind("/tmp/shrome")
  # server.settimeout(0)
  server.listen(5)
  connections = []
  tosend = []
  while True:
    # send and receive data
    for sock, addr in connections:

      # receive
      msg = ''
      stderr("getting res")
      msg = getbuf(sock)
      if msg == b'':
        stderr("sock closed")
        connections.remove((sock, addr))
        break
      else:
        stderr("msg: {}".format(msg))
        server_queue.put({"text": msg, "addr": addr})

      # check queue
      stderr("waiting")
      data = client_queue.get()
      stderr("done waiting")
      if data == None: break
      tosend.append(data)

      # send data
      for data in tosend:
        if 'text' in data:
          msg = data['text']
        elif 'err' in data:
          msg = data['err']
        send_addr = data['addr']
        stderr("addr: {}".format(addr))
        stderr("send_addr: {}".format(send_addr))

        if send_addr == addr:
          stderr("data: {}".format(data))
          try: sock.sendall(msg.encode('utf-8'))
          except Exception as err:
            stderr("send fail: {}".format(err))
            pass
          tosend.remove(data)

      msg = getbuf(sock)
      if msg == b'':
        stderr("sock closed")
        connections.remove((sock, addr))
        break

    # check for new connections
    try:
      sock, addr = server.accept()
      # sock.settimeout(0)
      stderr("new client {}".format(addr))
      connections.append((sock, addr))
    # except BlockingIOError # python3
    except socket.error:
      pass

    
  server.close()
  os.remove("/tmp/shrome")


def main():
  native_queue = Queue()
  server_queue = Queue()
  client_queue = Queue()

  native_thread = threading.Thread(target=native_func, args=(native_queue,))
  native_thread.setName("Native")
  native_thread.daemon = True
  native_thread.start()

  server_thread = threading.Thread(target=serve_func, args=(server_queue, client_queue))
  server_thread.setName("Server")
  server_thread.daemon = True
  server_thread.start()

  main_obj = Main(native_queue, server_queue, client_queue)
  main_obj.run()
  sys.exit(0)

if __name__ == '__main__':
  main()
